<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Archery Challenge - Enhanced Graphics</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: linear-gradient(180deg, #0d1117 0%, #161b22 100%);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      user-select: none;
    }
    canvas {
      display: block;
      background: radial-gradient(circle at bottom left, #223344 40%, #101820 100%);
      box-shadow: 0 0 20px #00ff99aa inset;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    const towerX = canvas.width / 4;
    const towerY = canvas.height - 150;
    const towerWidth = 100;
    const towerHeight = 180;

    let mouseX = towerX;
    let mouseY = towerY;

    const playerArrows = [];
    const enemyArrows = [];
    let isCharging = false;

    let level = 1;
    const maxLevel = 50;

    const enemies = [];

    class Arrow {
      constructor(x, y, angle, speed = 22) {
        this.x = x;
        this.y = y;
        this.speed = speed;
        this.vx = Math.cos(angle) * this.speed;
        this.vy = Math.sin(angle) * this.speed;
        this.angle = angle;
        this.active = true;
      }
      update() {
        this.x += this.vx;
        this.y += this.vy;
        // Gravity, less for longer flight
        this.vy += 0.08;

        // Collision player arrow -> enemies
        if (playerArrows.includes(this)) {
          enemies.forEach(enemy => {
            if (
              this.active &&
              this.x > enemy.x && this.x < enemy.x + enemy.size &&
              this.y > enemy.y && this.y < enemy.y + enemy.size
            ) {
              enemy.hit = true;
              this.active = false;
            }
          });
        }

        // Collision enemy arrow -> tower
        if (enemyArrows.includes(this)) {
          if (
            this.active &&
            this.x > towerX - towerWidth / 2 &&
            this.x < towerX + towerWidth / 2 &&
            this.y > towerY - towerHeight &&
            this.y < towerY
          ) {
            // Torre colpita
            alert("Sei stato colpito da un nemico!");
            this.active = false;
          }
        }

        if (this.y > canvas.height || this.x > canvas.width || this.x < 0 || this.y < 0) this.active = false;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        // Corpo freccia
        let grad = ctx.createLinearGradient(-10, 0, 10, 0);
        grad.addColorStop(0, "#b8860b");
        grad.addColorStop(0.5, "#ffd700");
        grad.addColorStop(1, "#b8860b");
        ctx.fillStyle = grad;
        ctx.fillRect(-10, -3, 20, 6);

        // Piume dettagliate
        ctx.fillStyle = "#fff8dc";
        ctx.beginPath();
        ctx.moveTo(-10, -3);
        ctx.lineTo(-16, -8);
        ctx.lineTo(-12, 0);
        ctx.lineTo(-16, 8);
        ctx.lineTo(-10, 3);
        ctx.closePath();
        ctx.fill();

        // Punta freccia
        ctx.fillStyle = "#555";
        ctx.beginPath();
        ctx.moveTo(10, 0);
        ctx.lineTo(20, -5);
        ctx.lineTo(20, 5);
        ctx.closePath();
        ctx.fill();

        ctx.restore();
      }
    }

    class Enemy {
      constructor(x, y) {
        this.x = x;
        this.y = y;
        this.size = 60;
        this.hit = false;
        this.bobPhase = Math.random() * Math.PI * 2;
      }
      draw() {
        ctx.save();
        ctx.translate(this.x, this.y + Math.sin(Date.now() * 0.005 + this.bobPhase) * 5);

        // Corpo ellittico sfumato
        const grad = ctx.createRadialGradient(this.size / 2, this.size / 2, 10, this.size / 2, this.size / 2, this.size / 1.3);
        grad.addColorStop(0, this.hit ? "#555" : "#e03e3e");
        grad.addColorStop(1, this.hit ? "#222" : "#8b0000");
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.ellipse(this.size / 2, this.size / 2, this.size / 2, this.size / 2 * 0.85, 0, 0, Math.PI * 2);
        ctx.fill();

        // Occhi bianchi luminosi
        ctx.fillStyle = "white";
        ctx.shadowColor = "#fff";
        ctx.shadowBlur = 10;
        ctx.beginPath();
        ctx.ellipse(this.size * 0.32, this.size * 0.4, 10, 14, 0, 0, Math.PI * 2);
        ctx.ellipse(this.size * 0.68, this.size * 0.4, 10, 14, 0, 0, Math.PI * 2);
        ctx.fill();

        // Pupille nere con riflessi
        ctx.shadowBlur = 0;
        ctx.fillStyle = "black";
        ctx.beginPath();
        ctx.ellipse(this.size * 0.32, this.size * 0.4, 5, 8, 0, 0, Math.PI * 2);
        ctx.ellipse(this.size * 0.68, this.size * 0.4, 5, 8, 0, 0, Math.PI * 2);
        ctx.fill();

        // Bocca arrabbiata
        ctx.strokeStyle = this.hit ? "#444" : "#300000";
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(this.size * 0.25, this.size * 0.78);
        ctx.quadraticCurveTo(this.size / 2, this.size * 0.65, this.size * 0.75, this.size * 0.78);
        ctx.stroke();

        ctx.restore();
      }
      tryToShoot() {
        if (this.hit) return;
        if (Math.random() < 0.10) {
          const dx = towerX - (this.x + this.size / 2);
          const dy = (towerY - towerHeight / 2) - (this.y + this.size / 2);
          const angle = Math.atan2(dy, dx);
          enemyArrows.push(new Arrow(this.x + this.size / 2, this.y + this.size / 2, angle, 14));
        }
      }
    }

    function spawnEnemies(level) {
      enemies.length = 0;
      for (let i = 0; i < Math.min(level, 5); i++) {
        const x = canvas.width / 2 + i * 120;
        const y = canvas.height - 220 - i * 70;
        enemies.push(new Enemy(x, y));
      }
      enemyArrows.length = 0;
    }

    function drawTower() {
      ctx.save();
      // Corpo torre
      const towerGrad = ctx.createLinearGradient(towerX - towerWidth / 2, towerY - towerHeight, towerX + towerWidth / 2, towerY);
      towerGrad.addColorStop(0, "#555555");
      towerGrad.addColorStop(1, "#222222");
      ctx.fillStyle = towerGrad;
      ctx.shadowColor = "#000";
      ctx.shadowBlur = 15;
      ctx.fillRect(towerX - towerWidth / 2, towerY - towerHeight, towerWidth, towerHeight);

      // Finestra torre luminosa
      const windowX = towerX - 25;
      const windowY = towerY - towerHeight + 40;
      const windowWidth = 50;
      const windowHeight = 80;

      const windowGrad = ctx.createLinearGradient(windowX, windowY, windowX + windowWidth, windowY + windowHeight);
      windowGrad.addColorStop(0, "#aaddff");
      windowGrad.addColorStop(1, "#003366");
      ctx.fillStyle = windowGrad;
      ctx.shadowColor = "#33aaff";
      ctx.shadowBlur = 15;
      ctx.fillRect(windowX, windowY, windowWidth, windowHeight);

      // Contorni torre
      ctx.shadowBlur = 0;
      ctx.strokeStyle = "#111";
      ctx.lineWidth = 6;
      ctx.strokeRect(towerX - towerWidth / 2, towerY - towerHeight, towerWidth, towerHeight);

      ctx.restore();
    }

    function drawPlayer(angle) {
      ctx.save();
      ctx.translate(towerX, towerY - towerHeight);

      // Corpo giocatore
      const bodyGrad = ctx.createLinearGradient(-15, -50, 15, 0);
      bodyGrad.addColorStop(0, "#666");
      bodyGrad.addColorStop(1, "#bbb");
      ctx.fillStyle = bodyGrad;
      ctx.shadowColor = "#888";
      ctx.shadowBlur = 8;
      ctx.fillRect(-12, -50, 24, 50);

      // Testa
      ctx.beginPath();
      ctx.fillStyle = "#f2cfa9";
      ctx.shadowColor = "#f2cfa9";
      ctx.shadowBlur = 12;
      ctx.arc(0, -65, 15, 0, Math.PI * 2);
      ctx.fill();

      // Occhi (semplici)
      ctx.shadowBlur = 0;
      ctx.fillStyle = "#222";
      ctx.beginPath();
      ctx.ellipse(-6, -68, 4, 6, 0, 0, Math.PI * 2);
      ctx.ellipse(6, -68, 4, 6, 0, 0, Math.PI * 2);
      ctx.fill();

      // Braccio e arco
      ctx.rotate(angle);
      const armGrad = ctx.createLinearGradient(0, -5, 40, 5);
      armGrad.addColorStop(0, "#8b5e3c");
      armGrad.addColorStop(1, "#4a2c15");
      ctx.fillStyle = armGrad;
      ctx.shadowColor = "#5a3319";
      ctx.shadowBlur = 6;
      ctx.fillRect(0, -5, 42, 10);

      // Corda arco
      ctx.strokeStyle = "#220000";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, -5);
      ctx.lineTo(0, 5);
      ctx.stroke();

      ctx.restore();
    }

    function drawLevel() {
      ctx.fillStyle = "#aaffcc";
      ctx.font = "22px 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif";
      ctx.shadowColor = "#0f4d44";
      ctx.shadowBlur = 10;
      ctx.fillText(`Level: ${level}`, 30, 40);
      ctx.shadowBlur = 0;
    }

    function gameLoop() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      drawTower();

      const dx = mouseX - towerX;
      const dy = mouseY - (towerY - towerHeight);
      const angle = Math.atan2(dy, dx);

      drawPlayer(angle);

      // Update and draw player arrows
      playerArrows.forEach(arrow => {
        arrow.update();
        arrow.draw();
      });
      for (let i = playerArrows.length - 1; i >= 0; i--) {
        if (!playerArrows[i].active) playerArrows.splice(i, 1);
      }

      // Enemies draw and shoot
      enemies.forEach(enemy => {
        enemy.draw();
        enemy.tryToShoot();
      });

      // Update and draw enemy arrows
      enemyArrows.forEach(arrow => {
        arrow.update();
        arrow.draw();
      });
      for (let i = enemyArrows.length - 1; i >= 0; i--) {
        if (!enemyArrows[i].active) enemyArrows.splice(i, 1);
      }

      drawLevel();

      if (enemies.every(e => e.hit)) {
        if (level < maxLevel) {
          level++;
          spawnEnemies(level);
          playerArrows.length = 0;
          enemyArrows.length = 0;
        }
      }

      requestAnimationFrame(gameLoop);
    }

    canvas.addEventListener("mousemove", e => {
      mouseX = e.clientX;
      mouseY = e.clientY;
    });

    canvas.addEventListener("mousedown", () => {
      isCharging = true;
    });

    canvas.addEventListener("mouseup", () => {
      if (isCharging) {
        const dx = mouseX - towerX;
        const dy = mouseY - (towerY - towerHeight);
        const angle = Math.atan2(dy, dx);
        playerArrows.push(new Arrow(towerX, towerY - towerHeight, angle, 24));
        isCharging = false;
      }
    });

    spawnEnemies(level);
    gameLoop();

    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
